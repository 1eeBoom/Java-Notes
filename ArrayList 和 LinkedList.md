# ArrayList和 LinkedList

## ArrayList

底层基于Object数组实现，实现了RandomAccess接口，支持随机访问。

默认的容量为 10，且每一次扩容都是 1.5 倍。

采用惰性分配空间策略，如果一开始没有设置大小的时候，实际数组大小为 0，等待第一次添加元素时候，会将数组大小扩容为 10。

### 扩容过程

每次向容器中添加元素，都会先计算添加完元素的大小是否超出了容量，如果超出则容器会自动扩容底层Object数组的大小。

add 方法：

1. 先判断数组是不是默认的空数组，如果是则将容量置为默认的容量
2. 如果添加元素后的数组预期容量超过了现有容量，则扩容至现有容量的 1.5 倍，如果扩容之后发现也无法满足预期容量，则将预期容量作为数组的容量。
3. 在扩容的时候，会创建一个原数组的副本，但是这个副本数组的大小为新容量，然后将数组引用指向这个新数组。接着再向 这个数组中添加新元素。

### 快速失败fast-fail机制

快速失败（fail—fast）
在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出 Concurrent Modification Exception。

原理：集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。而迭代器在初始化时，会将当时集合的modCount作为自己的modCount。迭代器在遍历时直接访问集合中的内容，并且在遍历过程中会校验modCount的值是否发生变化，会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。
但及时如此也不能使用该机制保证ArrayList的线程安全，如果集合发生变化时修改 modCount 值刚好又设置为了 expectedmodCount 值，则异常不会抛出。



## LinkedList

底层基于双向链表实现，链表中的每一个节点都包含了对前一个节点和后一个节点的引用。

同时还维护着链表的头结点和尾结点。

不存在扩容这个概念。



## ArrayList 和 LinkedList 区别

1. 底层结构上 ArrayList 采用的是数组，而 LinkedList 采用的是双向链表
2. 在随机访问数据的时候，ArrayList 可以通过下表直接获取到指定元素，而 LinkedList 需要逐个遍历，因此 ArrayList 的效率更更高。
3. 在增加元素的时候，如果是在尾部添加，那么效率基本一样，但是如果是在某个位置上出入元素，ArrayList 需要进行数据的移动，LinkedList 采用链表结构效率会更高
4. 开销方面，ArrayList 采用的是数组，存在需要扩容和预留空间的情况，但是 LinkedList 每个节点都需要存储前后节点信息。

当操作是在一列数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList会提供比较好的性能；当你的操作是在一列数据的前面或中间添加或删除数据,并且按照顺序访问其中的元素时,就应该使用LinkedList了。

