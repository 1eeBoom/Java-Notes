# MySQL 锁

[toc]



## 1.MySQL 锁

![img](https://blog-1257815336.cos.ap-nanjing.myqcloud.com/typora/v2-ed75345f32a89121c578e313ead82d07_720w.jpg)



### 锁实现机制

锁的思想主要有两种：

1. 悲观锁
2. 乐观锁

#### 悲观锁

悲观锁总是假设最坏的情况，即每次读取数据的时候都认为会被其他线程修改，所以每次操作都加锁。

MySQL 中的行锁，表锁等都是悲观锁，在做操作前先上锁。

Java 中的 synchronized 和 reentrantlock 也是悲观锁

##### 实现方式

###### synchronized

###### reentrantlock

#### 乐观锁

每次读写数据的时候都认为别人不会修改该数据，所以不会上锁，但是在提交更新的时候回判断下期间数据是否被修改。

乐观锁一般用于`读多写少`的场景，相较于悲观锁，能够提高吞吐量。

##### 实现方式

###### MVCC

乐观锁的实现在 MySQL 中通过 MVCC，即数据版本控制来实现。

具体的实现方法为为数据库表添加一个数字类型的 version 字段来实现，当读取数据的时候，将 version 字段一同读取出来，

数据每更新一次就对数据版本的 version+1。当我们提交更新的时候，需要将数据库表中对应记录的当前版本 version 与第一次取出来的做比对，如果一致则更新，否则认为当前的更新数据是过期数据。



### 锁的粒度

InnoDB 引擎下，支持行锁和表锁

#### 行锁

行锁的锁定粒度在 MySQL 中是最细的，只针对当前操作的行进行加锁。因此发生冲突的概率也最低。

但是相对的开销较大且加锁慢，有概率出现死锁。

需要注意的是，行锁仅针对索引列生效，或者更具体的来说，是检索数据时需要通过索引来检索。

`因为行锁是通过给索引项加锁来实现的`

**行锁的死锁产生**

行锁的获取步骤：

锁住主键索引 + 锁住非主键索引

当两个事务同时执行时，一个锁住了主键索引，在等待其他索引；另一个锁住了非主键索引，在等待主键索引。这样便会发生死锁。 InnoDB一般都可以检测到这种死锁，并使一个事务释放锁回退，另一个获取锁完成事务。

当不通过索引条件查询的时候，InnoDB会使用表锁。

#### 表锁

表锁会锁定整张表，粒度比行锁大，但是可以避免死锁。且实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。

当在执行写操作的时候，会先获取写锁。ALTER TABLE 之类的语句使用表级锁，而忽略存储引擎的锁机制。



#### 行锁和表锁的实现方式

InnoDB行锁是通过给索引上的索引项加锁来实现的。所以，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。其他注意事项：

在不通过索引条件查询的时候，InnoDB使用的是表锁，而不是行锁。
由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以即使是访问不同行的记录，如果使用了相同的索引键，也是会出现锁冲突的。
当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。
即便在条件中使用了索引字段，但具体是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。



### 兼容性

兼容性的概念是针对行锁而言，InnoDB实现了两种行锁：

#### for update 和 lock in share mode 的区别：

前一个上的是排他锁（X 锁），一旦一个事务获取了这个锁，其他的事务是没法在这些数据上执行 for update ；后一个是共享锁，多个事务可以同时的对相同数据执行 lock in share mode。


#### 共享锁/读锁

读锁，允许并发读取数据，但是任何事务不可以对数据进行修改，直到所有的读锁释放。



#### 排它锁/写锁

写锁，只允许当前事务对其进行读写操作，在这个事务执行结束之前，其他事务不能对该行加上任何锁。





### 算法

#### RecordLock 

单行记录上的锁，对索引项加锁

如果没有索引，则会对全表加锁

#### GapLock

`间隙锁` 锁定一个范围，但是`不包含记录本身`

锁定索引记录间隙，确保索引记录的间隙不变

间隙锁是针对事务隔离等级为可重复读以上级别配置的

>  Gap Lock在InnoDB的唯一作用就是防止其他事务的插入操作，以此防止幻读

#### Next-Key Lock

临键锁，Gap Lock + Record Lock，锁定一个范围，并且包含记录本身

当查询的索引包含唯一属性是，InnoDB 存储引起就会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅仅锁住索引本身，而不是范围。

当查询的索引为辅助索引时，默认使用Next-Key Locking技术进行加锁，锁定索引取值之间范围。





- 表锁，行锁在不同的场景下有各自的优势，具体看业务选型。
- 共享锁和互斥锁要合理应用，否则会导致死锁。
- MySQL四种隔离级别，除了串行化是不能解决幻读的，固引入了临键锁，间隙锁解决此问题。





innoDB默认的隔离级别是可重复读(Repeatable Read)，并且会以Next-Key Lock的方式对数据行进行加锁。Next-Key Lock是行锁和间隙锁的组合，当InnoDB扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。

当查询的索引含有唯一属性（唯一索引，主键索引）时，Innodb存储引擎会对next-key lock进行优化，将其降为record lock,即仅锁住索引本身，而不是范围。

2-3、何时使用行锁，何时产生间隙锁

对上一节的最后一句做个扩展说明。

1. 只使用唯一索引查询，并且只锁定一条记录时，innoDB会使用行锁。
2. 只使用唯一索引查询，但是检索条件是范围检索，或者是唯一检索然而检索结果不存在（试图锁住不存在的数据）时，会产生 Next-Key Lock。
3. 使用普通索引检索时，不管是何种查询，只要加锁，都会产生间隙锁。
4. 同时使用唯一索引和普通索引时，由于数据行是优先根据普通索引排序，再根据唯一索引排序，所以也会产生间隙锁。





