# MySQL 面试题

[toc]



## 1.MySQL 的事务隔离等级

SQL 定义了四个隔离级别：

1. 未提交读：允许读取其他事务未提交的更新
2. 已提交读：允许读取其他事物已提交的更新，可以阻止`脏读`
3. 可重复读：对同一个字段的多次读取结果是一致的，可以阻止`不可重复读`，也是 InnoDB索引下`默认的隔离等级。`
4. 串行化： 所有事务串行执行，可以阻止 `幻读`



### 事务隔离会产生的问题

1.脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而修改还未提交的时候，另一个事务也访问了这个数据。

2.不可重复读取：指在同一个事务内，多次读取同一个数据，多次读取之间，由于其他事务也对该数据进行了修改并提交，导致多次读取到数据不一致。

3.幻读：当一个事务对一个表中的数据进行范围读取时，发现前后的数据总量不一致。事务 A 对范围内数据读取多次，而多次读取之间，其他事务在该范围内增加或者删除了数据，导致多次读取到的数据总量不同。



#### 不可重复读和幻读的区别

不可重复读是读取了其他事务对数据的修改，针对 update 操作

幻读是读取了其他事务对数据的新增或者删除，针对 insert 和 delete 操作

不可重复读使用行级锁来锁定改行，事务完成后才释放该锁，允许其他事务对改行数据进行修改。

幻读需要使用Next-Key Lock 来锁定范围内的数据。



## 2.事务隔离的实现原理

> MySQL 事务隔离其实是依靠锁来实现的，加锁自然会带来性能的损失。

### 未提交读

未提交读隔离级别是不加锁的，所以它的性能是最好的，没有加锁、解锁带来的性能开销,但该隔离等级下任何事物下的修改数据都会立即暴露给其他事务。

事务在更新某数据，必须先对其加**行级共享锁**，直到事务结束才释放。

### 已提交读

已提交读隔离等级中

事务对当前被读取的数据加**行级共享锁**，一旦读完该行，立即释放该行级共享锁；

数据的更新操作会对数据加上**排他锁**，直到事务结束再释放

### 可重复读

事务对当前被读取的数据加**行级共享锁**，直到事务结束释放。

事务对当前被更新的数据加上**行级排他锁**，直到事务结束释放。

### 串行化

事务在读取数据时，必须先对其加**表级共享锁** ，直到事务结束才释放；

事务在更新数据时，必须先对其加**表级排他锁** ，直到事务结束才释放。

## 3.版本并发控制

### 实现机制

CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。整个CAS操作是一个原子操作，是不可分割的。

乐观锁的实现就类似于上面的过程，主要有以下几种方式：

- 版本号标记：在表中新增一个字段：version，用于保存版本号。获取数据的时候同时获取版本号，然后更新数据的时候用以下命令:`update xxx set version=version+1,… where … version="old version" and ....`。这时候通过判断返回结果的影响行数是否为0来判断是否更新成功，更新失败则说明有其他请求已经更新了数据了。
- 时间戳标记：和版本号一样，只是通过时间戳来判断。一般来说很多数据表都会有更新时间这一个字段，通过这个字段来判断就不用再新增一个字段了。
- 待更新字段：如果没有时间戳字段，而且不想新增字段，那可以考虑用待更新字段来判断，因为更新数据一般都会发生变化，那更新前可以拿要更新的字段的旧值和数据库的现值进行比对，没有变化则更新。

### 优缺点

**优点：**
乐观并发控制没有实际加锁，所以没有额外开销，也不错出现死锁问题，适用于读多写少的并发场景，因为没有额外开销，所以能极大提高数据库的性能。

**缺点：**
乐观并发控制不适合于写多读少的并发场景下，因为会出现很多的写冲突，导致数据写入要多次等待重试，在这种情况下，其开销实际上是比悲观锁更高的。而且乐观锁的业务逻辑比悲观锁要更为复杂，业务逻辑上要考虑到失败，等待重试的情况，而且也无法避免其他第三方系统对数据库的直接修改的情况。



## 4.多版本并发控制 MVCC

在实际使用过程中，数据库读请求是写请求的很多倍，我们如果能解决读写并发的问题的话，就能更大地提高数据库的读性能，而这就是多版本并发控制所能做到的事情。MVCC的出现就是数据库不满用悲观锁去解决读-写冲突问题，因性能不高而提出的解决方案。

### 实现方式

多版本并发控制的实现是通过保存数据在某个时间点的快照来实现的。

每个事务`读`到的数据项都是一个历史快照，被称为 **快照读**。不同于**当前读**的是快照读读到的数据可能不是最新的，但是快照隔离能使得在整个事务看到的数据都是`它启动时的数据状态`。

而 `写操作`不覆盖已有的数据项，而是创建一个新的版本，直到所在的事务提交时才变为可见。

### 快照读和当前读

#### 当前读

当前读，读取的是记录的最新版本，读取的时候还要保证其他事务不能修改当前记录，因此会对读取的记录进行加锁

#### 快照读

不加锁的读就是快照读，每个事务`读`到的数据项都是一个历史快照。快照读读到的数据可能不是最新的，但是快照隔离能使得在整个事务看到的数据都是`它启动时的数据状态`。

### 优缺点

MVCC 使大多数读操作都可以不用加锁，这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。

### MVCC的实现原理

每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID，记录最后一次修改该记录的事务ID

#### Read View(读视图)

###### 什么是Read View?

什么是Read View，说白了Read View就是事务进行**快照读操作的时候生产的读视图(Read View)**，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(`当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大`)。





