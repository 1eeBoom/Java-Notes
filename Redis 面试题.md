# Redis 面试

[toc]

## 1.Redis数据结构有哪些分别介绍下

### (1)String

String 是 redis 中最常使用的一种数据结构，常用的命令有 set,get,exists,setnx 等，他底层是 redis 自己创建的一种数据结构：简单动态字符串

#### SDS 简单动态字符串

动态字符串，是可以修改的字符串，内部结构上实现类似于 java的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。

当字符串小于 1M 的时候，每次扩容都是加倍现有的空间。

如果超过 1M，扩容时只增加 1M。

简单动态字符串内有 3 个属性:

len: 记录数组已用的长度

free: 数组剩余可用长度

buf: 实际保存字符串数据的数组

之所以 redis 自己创建一个数据结构而不是使用 C 自带的字符串结构的原因是因为

- 可以高效地执行长度计算（`strlen`）；
- 可以高效地执行追加操作（`append`）；
- 二进制安全；

### (2)List

list 就是链表，底层实现是一个`双向链表`结构，支持反向查询和便利。

常用命令有 rpush,lpop,lpush,rpop,lrange,llen,ltrim

应用场景一般是 热搜、发布与订阅



### (3)Hash

hash 字典，Redis 的 Hash 字典相当于 java 中的 HashMap,两者底层实现上都采用的是数组+链表的结构。

当发生 hash 冲突的时候，会使用拉链法存储。

#### 渐进式rehash

redis 为了高性能，在 rehash 的时候不是一次性的全部 rehash，而是采用了名为渐进式 rehash 的策略。

渐进式 rehash 简单的来说，就是在 rehash 过程中创建一个新的 hashtable 结构，并同时维护这两个hashtable 结构。

在查询的时候，同事查询这两个 hashTable结构，然后再后续的定时任务中，再循序渐进的将旧的 hashTable 中内容一点一点的迁移到新的 HashTable中。当某个时间全部迁移完成后，就会使用新的 HashTable 结构取而代之。

同时，在新数据过来的时候，会直接插入到新的 HashTable 中这一措施保证了 `ht[0]` 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。

当对旧的 HashTable 进行删除，更新，查找工作时，也会将其 rehash 到 新的HashTable 上

#### 压缩列表

当 `zset 和 hash` 容器对象在元素个数较小的情况下，会采用压缩列表去进行压缩。

压缩列表简单来说，就是一块`连续的内存空间`，元素之间紧挨着存储。

```c
struct ziplist<T> {
    int32 zlbytes; // 整个压缩列表占用字节数
    int32 zltail_offset; // 最后一个元素距离压缩列表起始位置的偏移量，用于快速定位到最后一个节点
    int16 zllength; // 元素个数
    T[] entries; // 元素内容列表，挨个挨个紧凑存储
    int8 zlend; // 标志压缩列表的结束，值恒为 0xFF
}
```



在压缩列表中，每个节点中会保存`前一个节点的大小`，这样就在倒着便利的时候就可以快速定位到前一个元素的地址。

```c
struct entry {
    int<var> prevlen; // 前一个 entry 的字节长度
    int<var> encoding; // 元素类型编码
    optional byte[] content; // 元素内容
}
```

当前一个元素的大小小于 254 的时候，prelen 只会使用一个字节进行存储

否则使用 5个字节

##### 连锁更新

前一个元素的大小变动会影响到后一个元素占用的空间大小，当前一个元素突然由原本 253增大到 255，后续节点的记录的 prevlen 就需要变成 5 个字节，有可能导致下一个节点的继续增大。

不过这种连锁更新的概率极小，需要每个节点都是在 250-253 之间。



##### 更新操作

因为 ziplist 都是紧凑存储，没有冗余空间 (对比一下 Redis 的字符串结构)。意味着插入一个新的元素就需要调用 realloc 扩展内存。取决于内存分配器算法和当前的 ziplist 内存大小，realloc 可能会重新分配新的内存空间，并将之前的内容一次性拷贝到新的地址，也可能在原有的地址上进行扩展，这时就不需要进行旧内容的内存拷贝。

如果 ziplist 占据内存太大，重新分配内存和拷贝内存就会有很大的消耗。所以 ziplist 不适合存储大型字符串，存储的元素也不宜过多。

### (4)Set

Redis 的结构相当于 HashSet

### (5)Zset

有序集合，相较于 Set,它还可以给每个 value 再赋予一个 score，代表权重。

内部实现是基于hash字典 +【跳跃列表】



#### 跳跃列表

跳表的最基础的结构还是一个双向链表

在双向链表的基础上，为了能够更快的查询到某个元素以及插入元素，跳跃链表的实现简单的来说就是每个几个元素挑选出一个出来，将挑选出来的元素串联，构成一个新的链表。然后继续重复上述步骤，最终形成一个类似金字塔的结构。

Redis 的跳跃表共有 64 层



##### 插入过程

对于每一个新插入的节点，都需要调用一个随机算法给它分配一个合理的层数。直观上期望的目标是 50% 的 Level1，25% 的 Level2，12.5% 的 Level3，一直到最顶层`2^-63`，因为这里每一层的晋升概率是 50%。



##### 更新过程

一个简单的策略就是先删除这个元素，再插入这个元素，需要经过两次路径搜索。Redis 就是这么干的。 



## 2.数据持久化

Redis 目前一共有两种持久化方案，分别是 快照RDB 和 只追加文件 AOF；

两种方案都有各自的好处和坏处

### RDB快照

Redis 可以通过创建快照来获取内存在某个时间点的上的副本。

### AOF

只追加文件写入 aof 和快照 rdb 相比，aof的好处是实时性更高。

目前追加写入的策略一共有 3 个：

always 即每次有数据修改发生的时候都会写入 aof 文件

everysecond 每秒写入

no 让操作系统自己决定什么时候写入



rdb 和 aof 各有优劣

rdb 是内存数据的快照，一般来说快照文件较小，当 redis 宕机恢复的时候速度会比较快

aof 则是操作指令的集合，实时性较高，但是文件较大，恢复起来也比较慢。



#### AOF 重写

为了解决 AOF 策略下存在的体积问题，redis 也提供了 aof 重写操作。

这个重写并非是在原来的 AOF 文件基础上重写，而是根据内存中的数据来进行的重写。

针对在重写过程中存在的并发写入问题，redis 会维护一个 AOF 重写缓冲区，将期间对 redis 的写入操作记录下来，等重写的 AOF 完成后，在将缓冲区内的所有命令追加到新的 AOF 文件末尾，并用新的 AOF 文件 替换旧的 AOF 文件。



## 3.过期数据删除

### 如何判断数据过期

redis 中有一个过期字典，它用来保存数据过期的时间，过期字典的键就是 redis 数据库中的某个 key。value 则是过期时间的时间戳。

### 过期删除策略

Redis 过期删除策略目前有两种

#### 惰性删除

只有在我们主动去使用这个 key 的时候，才会对数据进行过期检查。

这样做的好处是对cpu 比较友好，不用频繁扫描过期字典。但是坏处就是内存中会有大量的过期 key 未删除

#### 定期删除

定期删除每隔一段时间就会从过期词典中抽取一批 key ，将其中过期的删除，如果删除的数据超过一定比例之后会继续重复步骤。

这样做的好处是对内存比较友好，定期删除可以有效的减少内存中过期数据的占用。



目前 redis 采用的方案是 `惰性删除+定期删除`

兼顾了 CPU 和内存使用上的均衡



### 数据淘汰策略

当 redis 出现内存满了以后，新添加的数据则会被淘汰

目前 redis 提提6 中数据淘汰策略：

1.volatile-lru:从已经设置了过期时间的数据集中挑选出最近最少使用的数据淘汰

2.volatile-ttl:从已设置过期时间的数据集中挑选将要过期的数据淘汰

3.volatile-random:从已经设置过期时间的数据中随机挑选数据进行淘汰

4.allkeys-lru:从所有的数据中移除最近最少使用的数据

5.allkeys-random:从数据中任意选择一个淘汰

6.no:禁止驱逐数据，写入会报错。





## 4.Redis事务

Redis 的事务可以通过 MULTI 命令来进行开启，通过 EXEC 命令来执行

但是 redis 的事务的原子性是不完整的，因为 redis 不支持回滚操作。当事务执行过程中出现了错误，之前的操作结果仍然会保留下来。

## 5.Redis为什么这么快

Redis 是单线程，那为什么 Redis 仍然可以这么快呢？

redis 作为数据库，和 Mysql最大的不同在于它是基于内存实现的。

所有的数据都存放在内存上，因此速度自然要比从磁盘中获取来的迅速

按照官方给出的 QPS 测试，单机的 redis 可以达到 10W qps

Redis 这么快有几个原因：

1.完全基于内存，绝大部分请求都是内存操作。

2.Redis 针对数据结构做了优化，比如跳表

3.采用单线程，避免了不必要的线程切换和竞争而消耗额外的资源

4.使用IO 多路复用模型



## 6.Redis 为什么采用单线程

1.单线程模型更好维护，方便开发和调试

2.使用单线程的 redis 同样可以并发的处理客户端的请求

3.多线程是为了更好的利用 cpu 性能，多线程技术能够帮助我们充分利用 CPU 的计算资源来并发的执行不同的任务，但是Redis服务的瓶颈不是 cpu



## 7.IO 多路复用机制

网络 IO 的处理流程：

1.listen：监听客户端请求

2.accept：和客户端建立连接 `阻塞`

3.recv：从客户端获取数据 `阻塞`

accept 和 recv 两步都会有阻塞的可能，从而导致 redis 整个线程阻塞。



为此 redis 设计了一套以事件为基础的 IO 多路复用机制

当 redis 服务器进行操作时，会创建不同的套接字，创建完套接字后，redis 线程就可以返回处理其他操作，而不用在套接字上阻塞。

同时套接字也会有响应的机制来监听，也就是 IO 多路复用机制

IO 多路复用机制是指，一个线程处理多个 io 流，redis 是基于 epoll 来实现的。

简单的来说，在 redis 单线程的情况下，io 多路复用允许同时存在多个监听套接字和已连接套接字，内核会一直监听这些套接字上的数据和请求。一旦有请求到达，就会交给 redis 线程处理。

那么如何监听这些套接字，其实就是通过 epoll 来实现的。

![image-20210531135842981](https://blog-1257815336.cos.ap-nanjing.myqcloud.com/typora/image-20210531135842981.png)

### epoll

**该机制允许内核中，同时存在多个监听套接字和已连接套接字**

为了在请求到达时，能够及时通知 redis 线程，epoll 它提供了基于事件的回调机制。

即针对不同的事件，提供不同的处理方法。

当epoll 一旦检测到监听套接字 FD 上请求到达，就会触发相应的事件，并将这些事件放入到一个队列中，而 redis 单线程则会对该队列不断的进行出队处理。





## 8.缓存失效

### 缓存雪崩

**缓存雪崩**

缓存雪崩是指`在某一个时刻`出现一个`大规模`key 过期，那么就导致了大量的请求打在了数据库上面，导致数据库压力巨大。

如果在高并发的情况下，很可能就导致数据库宕机，如果此时马上重启数据库，又会有新的流量吧数据库打死，这就是缓存雪崩。

**问题产生原因**

缓存雪崩产生的直接原因是同一时间大规模的 key 失效。

根本原因有两种可能：

1.Redis 宕机导致 缓存查询全部失败

2.key 采用了相同的过期时间

**解决方案**

事前：

1.设置不同的过期时间，让缓存失效的时间尽量均匀一点

2.热点数据永不过期，对于热点数据可以开启后台定时任务，定时刷新

3.redis 集群保证高可用

事中：

1.添加限流：当流量超过一定阈值后，直接返回网络拥堵或者系统拥堵，防止过多的请求打到数据库上。

2.使用分布式锁：某个 Key 只允许一个线程查询数据库与写缓存，其他线程等待。

事后：

1.开启 redis 持久化机制，尽快恢复数据缓存数据。

### 缓存击穿

**缓存击穿**

缓存击穿和雪崩有点类似，不同的是，雪崩是大面积的 key失效，而击穿则是`某个热点 key 失效的瞬间，大并发集中对其进行请求`，就会造成同一时间大量请求读缓存没读到数据，从而导致后续高并发访问数据库，引起数据库压力剧增。这种现象叫做缓存击穿。

**解决方案**

1.在缓存失效后，通过分布式锁控制读数据写缓存的线程数量，指定 key 同一时间只允许一个线程查询数据和写缓存

### 缓存穿透

描述：

缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。 

解决方案：

接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；
从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击
