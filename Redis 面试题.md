# Redis 面试

[toc]

## 1.Redis数据结构有哪些分别介绍下

### (1)String

String 是 redis 中最常使用的一种数据结构，常用的命令有 set,get,exists,setnx 等，他底层是 redis 自己创建的一种数据结构：简单动态字符串

#### SDS 简单动态字符串

动态字符串，是可以修改的字符串，内部结构上实现类似于 java的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。

当字符串小于 1M 的时候，每次扩容都是加倍现有的空间。

如果超过 1M，扩容时只增加 1M。

简单动态字符串内有 3 个属性:

len: 记录数组已用的长度

free: 数组剩余可用长度

buf: 实际保存字符串数据的数组

之所以 redis 自己创建一个数据结构而不是使用 C 自带的字符串结构的原因是因为

- 可以高效地执行长度计算（`strlen`）；
- 可以高效地执行追加操作（`append`）；
- 二进制安全；

### (2)List

list 就是链表，底层实现是一个`双向链表`结构，支持反向查询和便利。

常用命令有 rpush,lpop,lpush,rpop,lrange,llen,ltrim

应用场景一般是 热搜、发布与订阅



### (3)Hash

hash 字典，Redis 的 Hash 字典相当于 java 中的 HashMap,两者底层实现上都采用的是数组+链表的结构。

当发生 hash 冲突的时候，会使用拉链法存储。

#### 渐进式rehash

redis 为了高性能，在 rehash 的时候不是一次性的全部 rehash，而是采用了名为渐进式 rehash 的策略。

渐进式 rehash 简单的来说，就是在 rehash 过程中创建一个新的 hashtable 结构，并同时维护这两个hashtable 结构。

在查询的时候，同事查询这两个 hashTable结构，然后再后续的定时任务中，再循序渐进的将旧的 hashTable 中内容一点一点的迁移到新的 HashTable中。当某个时间全部迁移完成后，就会使用新的 HashTable 结构取而代之。

同时，在新数据过来的时候，会直接插入到新的 HashTable 中这一措施保证了 `ht[0]` 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。

当对旧的 HashTable 进行删除，更新，查找工作时，也会将其 rehash 到 新的HashTable 上

#### 压缩列表

当 `zset 和 hash` 容器对象在元素个数较小的情况下，会采用压缩列表去进行压缩。

压缩列表简单来说，就是一块`连续的内存空间`，元素之间紧挨着存储。

```c
struct ziplist<T> {
    int32 zlbytes; // 整个压缩列表占用字节数
    int32 zltail_offset; // 最后一个元素距离压缩列表起始位置的偏移量，用于快速定位到最后一个节点
    int16 zllength; // 元素个数
    T[] entries; // 元素内容列表，挨个挨个紧凑存储
    int8 zlend; // 标志压缩列表的结束，值恒为 0xFF
}
```



在压缩列表中，每个节点中会保存`前一个节点的大小`，这样就在倒着便利的时候就可以快速定位到前一个元素的地址。

```c
struct entry {
    int<var> prevlen; // 前一个 entry 的字节长度
    int<var> encoding; // 元素类型编码
    optional byte[] content; // 元素内容
}
```

当前一个元素的大小小于 254 的时候，prelen 只会使用一个字节进行存储

否则使用 5个字节

##### 连锁更新

前一个元素的大小变动会影响到后一个元素占用的空间大小，当前一个元素突然由原本 253增大到 255，后续节点的记录的 prevlen 就需要变成 5 个字节，有可能导致下一个节点的继续增大。

不过这种连锁更新的概率极小，需要每个节点都是在 250-253 之间。



##### 更新操作

因为 ziplist 都是紧凑存储，没有冗余空间 (对比一下 Redis 的字符串结构)。意味着插入一个新的元素就需要调用 realloc 扩展内存。取决于内存分配器算法和当前的 ziplist 内存大小，realloc 可能会重新分配新的内存空间，并将之前的内容一次性拷贝到新的地址，也可能在原有的地址上进行扩展，这时就不需要进行旧内容的内存拷贝。

如果 ziplist 占据内存太大，重新分配内存和拷贝内存就会有很大的消耗。所以 ziplist 不适合存储大型字符串，存储的元素也不宜过多。

### (4)Set

Redis 的结构相当于 HashSet

### (5)Zset

有序集合，相较于 Set,它还可以给每个 value 再赋予一个 score，代表权重。

内部实现是基于hash字典 +【跳跃列表】



#### 跳跃列表

跳表的最基础的结构还是一个双向链表

在双向链表的基础上，为了能够更快的查询到某个元素以及插入元素，跳跃链表的实现简单的来说就是每个几个元素挑选出一个出来，将挑选出来的元素串联，构成一个新的链表。然后继续重复上述步骤，最终形成一个类似金字塔的结构。

Redis 的跳跃表共有 64 层



##### 插入过程

对于每一个新插入的节点，都需要调用一个随机算法给它分配一个合理的层数。直观上期望的目标是 50% 的 Level1，25% 的 Level2，12.5% 的 Level3，一直到最顶层`2^-63`，因为这里每一层的晋升概率是 50%。



##### 更新过程

一个简单的策略就是先删除这个元素，再插入这个元素，需要经过两次路径搜索。Redis 就是这么干的。 



## 2.数据持久化

Redis 目前一共有两种持久化方案，分别是 快照RDB 和 只追加文件 AOF；

两种方案都有各自的好处和坏处

### RDB快照

Redis 可以通过创建快照来获取内存在某个时间点的上的副本。

### AOF

只追加文件写入 aof 和快照 rdb 相比，aof的好处是实时性更高。

目前追加写入的策略一共有 3 个：

always 即每次有数据修改发生的时候都会写入 aof 文件

everysecond 每秒写入

no 让操作系统自己决定什么时候写入



rdb 和 aof 各有优劣

rdb 是内存数据的快照，一般来说快照文件较小，当 redis 宕机恢复的时候速度会比较快

aof 则是操作指令的集合，实时性较高，但是文件较大，恢复起来也比较慢。



#### AOF 重写

为了解决 AOF 策略下存在的体积问题，redis 也提供了 aof 重写操作。

这个重写并非是在原来的 AOF 文件基础上重写，而是根据内存中的数据来进行的重写。

针对在重写过程中存在的并发写入问题，redis 会维护一个 AOF 重写缓冲区，将期间对 redis 的写入操作记录下来，等重写的 AOF 完成后，在将缓冲区内的所有命令追加到新的 AOF 文件末尾，并用新的 AOF 文件 替换旧的 AOF 文件。



## 3.过期数据删除

### 如何判断数据过期

redis 中有一个过期字典，它用来保存数据过期的时间，过期字典的键就是 redis 数据库中的某个 key。value 则是过期时间的时间戳。

### 过期删除策略

Redis 过期删除策略目前有两种

#### 惰性删除

只有在我们主动去使用这个 key 的时候，才会对数据进行过期检查。

这样做的好处是对cpu 比较友好，不用频繁扫描过期字典。但是坏处就是内存中会有大量的过期 key 未删除

#### 定期删除

定期删除每隔一段时间就会从过期词典中抽取一批 key ，将其中过期的删除，如果删除的数据超过一定比例之后会继续重复步骤。

这样做的好处是对内存比较友好，定期删除可以有效的减少内存中过期数据的占用。



目前 redis 采用的方案是 `惰性删除+定期删除`

兼顾了 CPU 和内存使用上的均衡



### 数据淘汰策略

当 redis 出现内存满了以后，新添加的数据则会被淘汰

目前 redis 提提6 中数据淘汰策略：

1.volatile-lru:从已经设置了过期时间的数据集中挑选出最近最少使用的数据淘汰

2.volatile-ttl:从已设置过期时间的数据集中挑选将要过期的数据淘汰

3.volatile-random:从已经设置过期时间的数据中随机挑选数据进行淘汰

4.allkeys-lru:从所有的数据中移除最近最少使用的数据

5.allkeys-random:从数据中任意选择一个淘汰

6.no:禁止驱逐数据，写入会报错。





## 4.Redis事务

Redis 的事务可以通过 MULTI 命令来进行开启，通过 EXEC 命令来执行

但是 redis 的事务的原子性是不完整的，因为 redis 不支持回滚操作。当事务执行过程中出现了错误，之前的操作结果仍然会保留下来。

## 5.Redis为什么这么快/IO 多路复用机制





