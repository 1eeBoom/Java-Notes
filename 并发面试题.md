# 并发

[toc]



## 1.MySQL 锁

![img](https://blog-1257815336.cos.ap-nanjing.myqcloud.com/typora/v2-ed75345f32a89121c578e313ead82d07_720w.jpg)



### 锁实现机制

锁的思想主要有两种：

1. 悲观锁
2. 乐观锁

#### 悲观锁

悲观锁总是假设最坏的情况，即每次读取数据的时候都认为会被其他线程修改，所以每次操作都加锁。

MySQL 中的行锁，表锁等都是悲观锁，在做操作前先上锁。

Java 中的 synchronized 和 reentrantlock 也是悲观锁

##### 实现方式

###### synchronized

###### reentrantlock

#### 乐观锁

每次读写数据的时候都认为别人不会修改该数据，所以不会上锁，但是在提交更新的时候回判断下期间数据是否被修改。

乐观锁一般用于`读多写少`的场景，相较于悲观锁，能够提高吞吐量。

##### 实现方式

###### MVCC

乐观锁的实现在 MySQL 中通过 MVCC，即数据版本控制来实现。

具体的实现方法为为数据库表添加一个数字类型的 version 字段来实现，当读取数据的时候，将 version 字段一同读取出来，

数据每更新一次就对数据版本的 version+1。当我们提交更新的时候，需要将数据库表中对应记录的当前版本 version 与第一次取出来的做比对，如果一致则更新，否则认为当前的更新数据是过期数据。



### 锁的粒度

InnoDB 引擎下，支持行锁和表锁

#### 行锁

行锁的锁定粒度在 MySQL 中是最细的，只针对当前操作的行进行加锁。因此发生冲突的概率也最低。

但是相对的开销较大且加锁慢，有概率出现思索。

需要注意的是，行锁仅针对索引列生效，或者更具体的来说，是检索数据时需要通过索引来检索。

`因为行锁是通过给索引项加锁来实现的`

**行锁的死锁产生**

行锁的获取步骤：

1.锁住主键索引

2.锁住非主键索引

当两个事务同时执行时，一个锁住了主键索引，在等待其他索引；另一个锁住了非主键索引，在等待主键索引。这样便会发生死锁。 InnoDB一般都可以检测到这种死锁，并使一个事务释放锁回退，另一个获取锁完成事务。

当不通过索引条件查询的时候，InnoDB会使用表锁。

#### 表锁

表锁会锁定整张表，粒度比行锁大，但是可以避免死锁。且实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。

当在执行写操作的时候，会先获取写锁。ALTER TABLE 之类的语句使用表级锁，而忽略存储引擎的锁机制。



### 兼容性

兼容性的概念是针对行锁而言，InnoDB实现了两种行锁：

#### for update 和 lock in share mode 的区别：

前一个上的是排他锁（X 锁），一旦一个事务获取了这个锁，其他的事务是没法在这些数据上执行 for update ；后一个是共享锁，多个事务可以同时的对相同数据执行 lock in share mode。


#### 共享锁/读锁

读锁，允许并发读取数据，但是任何事务不可以对数据进行修改，直到所有的读锁释放。



#### 排它锁/写锁

写锁，只允许当前事务对其进行读写操作，在这个事务执行结束之前，其他事务不能对该行加上任何锁。





### 算法

#### RecordLock 

单行记录上的锁

如果没有索引，则会对全表加锁

#### GapLock

`间隙锁` 锁定一个范围，但是`不包含记录本身`

锁定索引记录间隙，确保索引记录的间隙不变

间隙锁是针对事务隔离等级为可重复读以上级别配置的

>  Gap Lock在InnoDB的唯一作用就是防止其他事务的插入操作，以此防止幻读

#### Next-Key Lock

临键锁，Gap Lock + Record Lock，锁定一个范围，并且包含记录本身

当查询的索引包含唯一属性是，InnoDB 存储引起就会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅仅锁住索引本身，而不是范围。

当查询的索引为辅助索引时，默认使用Next-Key Locking技术进行加锁，锁定索引取值之间范围。





- 表锁，行锁在不同的场景下有各自的优势，具体看业务选型。
- 共享锁和互斥锁要合理应用，否则会导致死锁。
- MySQL四种隔离级别，除了串行化是不能解决幻读的，固引入了临键锁，间隙锁解决此问题。













