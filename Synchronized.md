# Synchronized

[toc]

> - Synchronized可以作用在哪里? 分别通过对象锁和类锁进行举例。
> - Synchronized本质上是通过什么保证线程安全的? 分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理。
> - Synchronized由什么样的缺陷?  Java Lock是怎么弥补这些缺陷的。
> - Synchronized和Lock的对比，和选择?
> - Synchronized在使用时有何注意事项?
> - Synchronized修饰的方法在抛出异常时,会释放锁吗?
> - 多个线程等待同一个snchronized锁的时候，JVM如何选择下一个获取锁的线程?
> - Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法?
> - 我想更加灵活地控制锁的释放和获取(现在释放锁和获取锁的时机都被规定死了)，怎么办?
> - 什么是锁的升级和降级? 什么是JVM里的偏斜锁、轻量级锁、重量级锁?
> - 不同的JDK中对Synchronized有何优化?



## Synchronized用法

注意，synchronized 内置锁 是一种 对象锁（锁的是对象而非引用变量），**作用粒度是对象 ，可以用来实现对 临界资源的同步互斥访问 ，是 可重入 的。其可重入最大的作用是避免死锁**

synchronized只能用于代码块或者方法，不可以用于类。如果要使用类锁，可以将类对象设为xxx.class或者修饰静态代码块。

一个对象有一把锁（class也是对象），且同时只能被一个线程获得。其他未获得锁的线程只能等待

每个实例对象都有一把锁(this)，且不同实例对象的锁互不影响，`除非：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象公用同一把锁`（也就是类锁）

synchroniezd修饰的方法，正常执行结束和抛出异常都会释放锁。



Synchronized的用法可以分为两种：对象锁和类锁

对象锁，有两种形式：代码块&&方法锁

代码块形式下，可以由用户自己指定 作为锁的对象 也可以 使用this。

方法锁，即使用synchronized关键字修饰方法名，该情况下默认使用this作为锁对象

类锁：synchronize修饰`静态的方法`或`指定锁对象为Class对象`





## 实现原理：

**java中每个对象都关联着一个监视器锁（monitor）**，每一个对象在同一时间只与一个monitor(锁)相关联。

和monitor有关的命令有两个

monitorenter:用于当前线程获取monitor

Monitorexit:用于当前线程释放monitor

### Monitorenter:

而一个monitor在同一时间只能被一个线程获得，一个线程在尝试获得与这个对象相关联的Monitor锁的所有权的时候，monitorenter指令会发生如下3中情况之一：

1. 当该monitor计数器count = 0时，意味着该锁还没有被线程获得，那么这个线程会立即取得monitor，并使计数器+1.+1后别的线程再想获取，就需要等待。
2. 如果同一线程获取锁后，想要再次重入，那么monitor count会再次+1，并随着重入次数的增多，count也不断增加。
3. 如果这个monitor 已经被其他线程获取了，那么等待释放。

### Monitorexit:

释放对于monitor的所有权，释放过程很简单，就是将monitor的计数器减1，如果减完以后，计数器不是0，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成0，则代表当前线程不再拥有该monitor的所有权，即释放锁。

![img](https://blog-1257815336.cos.ap-nanjing.myqcloud.com/typora/等待队列.png)



如上图所示，一个线程通过1号门进入Entry Set(入口区)，如果在入口区没有线程等待，那么这个线程就会获取监视器成为监视器的Owner，然后执行监视区域的代码。如果在入口区中有其它线程在等待，那么新来的线程也会和这些线程一起等待。线程在持有监视器的过程中，有两个选择，一个是正常执行监视器区域的代码，释放监视器，通过5号门退出监视器；还有可能等待某个条件的出现，于是它会通过3号门到Wait Set（等待区）休息，直到相应的条件满足后再通过4号门进入重新获取监视器再执行。

如果获取失败，该线程就进入同步状态，线程状态变为BLOCKED，当Object的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器。



## JVM中锁的优化

简单来说在JVM中monitorenter和monitorexit字节码依赖于底层的操作系统的Mutex Lock来实现的，但是由于`使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行`，这种切换的代价是非常昂贵的；然而在现实中的大部分情况下，同步方法是运行在单线程环境(无锁竞争环境)如果每次都调用Mutex Lock那么将严重的影响程序的性能。**不过在jdk1.6中对锁的实现引入了大量的优化，如锁粗化(Lock Coarsening)、锁消除(Lock Elimination)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)、适应性自旋(Adaptive Spinning)等技术来减少锁操作的开销**。

`锁粗化(Lock Coarsening)`：也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。

`锁消除(Lock Elimination)`：通过运行时JIT编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护，通过逃逸分析也可以在线程本地Stack上进行对象空间的分配(同时还可以减少Heap上的垃圾收集开销)。

`轻量级锁(Lightweight Locking)`：这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态(即单线程执行环境)，在无锁竞争的情况下完全可以`避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令`就可以完成锁的获取及释放。当存在锁竞争的情况下，`执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，`当锁被释放的时候被唤醒(具体处理步骤下面详细讨论)。

`偏向锁(Biased Locking)`：是为了在无锁竞争的情况下避免在锁获取过程中执行不必要的CAS原子指令，因为CAS原子指令虽然相对于重量级锁来说开销比较小但还是存在非常可观的本地延迟。

`适应性自旋(Adaptive Spinning)`：当线程在获取轻量级锁的过程中执行CAS操作失败时，在进入与monitor相关联的操作系统重量级锁(mutex semaphore)前会进入忙等待(Spinning)然后再次尝试，`当尝试一定的次数后如果仍然没有成功则调用与该monitor关联的semaphore(即互斥锁)进入到阻塞状态。`



## 锁的类型

在Java SE 1.6里Synchronied同步锁，一共有四种状态：`无锁`、`偏向锁`、`轻量级所`、`重量级锁`，它会随着竞争情况逐渐升级。锁可以升级但是不可以降级，目的是为了提供获取锁和释放锁的效率。

> 锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 (此过程是不可逆的)

### 自旋锁

在多进程竞争锁时，当一个线程获取到锁后，会阻塞其他尝试获取该所的线程。`线程的挂起和恢复`都需要要从用户态转入到内核态中完成，这个操作开销对操作系统的并发性能产生了一定的压力。

同时大部分的共享数据的锁定状态只会持续很短的时间，为了这段时间而去挂起和恢复线程并不值得。完全可以让另一个没有获取到锁的线程不放弃CPU时间片，不断的轮询锁是否释放，等待有锁的线程释放锁。

为了让线程等待，我们需要让线程执行自旋。

如果锁占用的时间非常的短，那么自旋锁的新能会非常的好，相反，其会带来更多的性能开销(因为在线程自旋时，始终会占用CPU的时间片，`如果锁占用的时间太长，那么自旋的线程会白白消耗掉CPU资源)。`

如果自选超过了限定的次数仍然没有成功获取到锁，就应该使用传统的方式去挂起线程了，在JDK定义中，自旋锁默认的自旋次数为10次，用户可以使用参数`-XX:PreBlockSpin`来更改。

可是现在又出现了一个问题：如果线程锁在线程自旋刚结束就释放掉了锁，那么是不是有点得不偿失。所以这时候我们需要`更加聪明的锁来实现更加灵活的自旋`。来提高并发的性能。(这里则需要自适应自旋锁！)

### 自适应自旋锁

自旋的时间不再固定了，而是由前一次在同一个锁上的自旋 时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待的线程刚刚成功获取过锁，并且持有锁的线程正在运行中，那么JVM会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间。比如增加到100次循环。相反，如果对于某个锁，自旋很少成功获取锁。那再以后要获取这个锁时将可能省略掉自旋过程直接挂起，以避免浪费处理器资源。

#### 锁消除

在编译时，对于一些代码上明确要求同步但是检测不存在共享数据竞争的锁进行消除。

消除的依据来自于 JVM会判断在一段程序中的需要同步的数据 明显不会逃逸出去 从而被其他线程访问到，那JVM就把它们当作栈上数据对待，认为这些数据时线程独有的，不需要加同步。此时就会进行锁消除。

在Java API中有很多方法都是加了同步的，那么此时JVM会判断这段代码是否需要加锁。如果数据并不会逃逸，则会进行锁消除。



#### 锁粗化

原则上，我们都知道在加同步锁时，尽可能的将同步块的作用范围限制到尽量小的范围(只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小。在存在锁同步竞争中，也可以使得等待锁的线程尽早的拿到锁)。

大部分上述情况是完美正确的，但是如果存在连串的一系列操作都对同一个对象反复加锁和解锁，甚至加锁操作时出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要地性能操作。

这里贴上根据上述Javap 编译地情况编写地实例java类

```java
public static String test04(String s1, String s2, String s3) {
    StringBuilder sb = new StringBuilder();
    sb.append(s1);
    sb.append(s2);
    sb.append(s3);
    return sb.toString();
}
    
```

在上述地连续append()操作中就属于这类情况。JVM会检测到这样一连串地操作都是对同一个对象加锁，那么JVM会将加锁同步地范围扩展(粗化)到整个一系列操作的 外部，使整个一连串地append()操作只需要加锁一次就可以了。

### 偏向锁：

在大多实际环境下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，那么在同一个线程反复获取所释放锁中，且其中没有锁的竞争，这种情况下，多次的获取锁和释放锁带来了很多不必要的性能开销和上下文切换。



为了解决这一问题，HotSpot的作者在Java SE 1.6 中对Synchronized进行了优化，引入了偏向锁。当一个线程访问同步代码块并获取锁时，会在对象头和栈帧中的锁记录里存储`锁偏向的线程ID`，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁。只需要简单地测试一下对象头的`Mark Word`里是否存储着指向当前线程的偏向锁。如果成功，表示线程已经获取到了锁。

![img](https://blog-1257815336.cos.ap-nanjing.myqcloud.com/typora/java-thread-x-key-schronized-8.png)

偏向锁的撤销



偏向锁使用了一种等待竞争出现才会释放锁的机制。所以当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。但是偏向锁的撤销需要等到全局安全点(就是当前线程没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程，让你后检查持有偏向锁的线程是否活着。如果线程不处于活动状态，直接将对象头设置为无锁状态。如果线程活着，JVM会遍历栈帧中的锁记录，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁。

![img](https://blog-1257815336.cos.ap-nanjing.myqcloud.com/typora/java-thread-x-key-schronized-9.png)

### 轻量级锁

需要注意的是轻量级锁并不是替代重量级锁的，而是对在大多数情况下`同步块并不会有竞争出现提出的一种优化`。它可以减少重量级锁对线程的阻塞带来地线程开销。从而提高并发性能。

对象头中(`Object Header`)存在两部分。第一部分用于存储对象自身的运行时数据，`HashCode`、`GC Age`、`锁标记位`、`是否为偏向锁`等。一般为32位或者64位(视操作系统位数定)。官方称之为`Mark Word`，它是实现轻量级锁和偏向锁的关键。 

在线程执行同步块之前，JVM会先在当前线程的栈帧中创建一个名为锁记录(`Lock Record`)的空间，用于存储锁对象目前的`Mark Word`的拷贝(JVM会将对象头中的`Mark Word`拷贝到锁记录中，官方称为`Displaced Mark Ward`)这个时候线程堆栈与对象头的状态如图

![img](https://blog-1257815336.cos.ap-nanjing.myqcloud.com/typora/对象头.png)





如上图所示：如果当前锁对象没有被线程锁定，那么锁标志位为01状态，JVM在执行当前线程时，首先会在当前线程栈帧中创建锁记录`Lock Record`的空间用于存储锁对象目前的`Mark Word`的拷贝。

当获取到锁的时候，虚拟机使用CAS操作将标记字段Mark Word拷贝到当前线程的锁记录中，并且将`Mark Word`更新为指向当前线程`Lock Record`的指针。如果更新成功了，那么这个线程就有用了该对象的锁，并且对象Mark Word的锁标志位更新为(`Mark Word`中最后的2bit)00，即表示此对象处于轻量级锁定状态，如图：

![img](https://blog-1257815336.cos.ap-nanjing.myqcloud.com/typora/java-thread-x-key-schronized-6-20201107211136547.png)



如果这个更新操作失败，JVM会检查当前的锁对象的`Mark Word`中是否存在指向当前线程的栈帧的指针，如果有，说明该锁已经被获取，可以直接调用。如果没有，则说明该锁被其他线程抢占了，如果有两条以上的线程竞争同一个锁，那轻量级锁就不再有效，直接膨胀位重量级锁，没有获得锁的线程会被阻塞。此时，锁的标志位为`10`  

`此时锁对象Mark Word`中存储的是指向重量级锁的指针。

轻量级解锁时，会使用原子的CAS操作将`Displaced Mark Word`替换回到对象头中，如果成功，则表示没有发生竞争关系。如果失败，表示当前锁存在竞争关系。锁就会膨胀成重量级锁。两个线程同时争夺锁，导致锁膨胀的流程图如下：

![img](https://blog-1257815336.cos.ap-nanjing.myqcloud.com/%20typora/%20java-thread-x-key-schronized-7.png)





## 锁的优缺点对比

| 锁       | 优点                                                         | 缺点                                                         | 使用场景                               |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------- |
| 偏向锁   | 加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗               | 适用于只有一个线程访问同步代码块的场景 |
| 轻量级锁 | 竞争的线程不会阻塞，提高了响应速度                           | 如线程成始终得不到锁竞争的线程，使用自旋会消耗CPU性能        | 追求响应时间，同步块执行速度非常快     |
| 重量级锁 | 线程竞争不适用自旋，不会消耗CPU                              | 线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗 | 追求吞吐量，同步块执行速度较长         |



## Synchronized和Lock

| 锁           | 优点                                                         | 缺点                                                         | 使用场景 |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- |
| Synchronized | 1.java的关键字，jvm原生支持<br />2.退出代码块和异常时都能释放锁 | 1.效率低，试图获取锁时不能设定超时时间。多线程竞争一个锁时，其余未得到锁的线程只能不停的尝试获得锁，而不能中断。高并发的情况下会导致性能下降<br />2.不够灵活，只能使用某个对象作为锁，且加锁和释放的时机单一<br />3.无法知道是否成功获得锁<br />4.锁的类型不可更改：可重入 不可中断 非公平 |          |
| Lock         | 1.接口                                                       |                                                              |          |

### 使用Synchronized有哪些要注意的？

- 锁对象不能为空，因为锁的信息都保存在对象头里
- 作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错
- 避免死锁
- 在能选择的情况下，既不要用Lock也不要用synchronized关键字，用java.util.concurrent包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用synchronized关键，因为代码量少，避免出错





### synchronized是公平锁吗？

synchronized实际上是非公平的，新来的线程有可能立即获得监视器，而在等待区中等候已久的线程可能再次等待，会导致饥饿。