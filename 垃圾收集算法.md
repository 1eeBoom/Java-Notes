## 垃圾收集算法

[toc]


### 分代收集理论

1）弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。新生代中的对象有98%熬不过第一轮收集。

2）强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。

收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。

Java堆划分为新生代（Young Generation）和老年代（Old Generation）两个区域

分代收集并非只是简单划分一下内存区域那么容易，它至少存在一个明显的困难：`对象不是孤立的，对象之间会存在跨代引用。`

但新生代中的对象是完全有可能被老年代所引用的，`为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样。`遍历整个老年代所有对象的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。为了解决这个问题，就需要对分代收集理论添加第三条经验法则：

3）跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。

举个例子，如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。

依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称为“`记忆集`”，Remembered Set,从非收集部分指向收集部分的指针的集合。），`这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描`。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。

1. 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。

2. 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前`只有CMS收集器会有单独收集老年代的行为。`另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。

3. 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。`目前只有G1收集器会有这种行为。`

4. 整堆收集（Full GC）：收集整个Java堆和`方法区`的垃圾收集。



### 标记-清除算法

#### 定义

先标记后清除：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。`标记过程就是对象是否属于垃圾的判定过程。`

#### 缺点

1. 第一个是==执行效率不稳定==，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，==这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；==
2. 第二个是==内存空间的碎片化==问题，==`标记、清除之后会产生大量不连续的内存碎片`==，空间碎片太多可能会导致当以后在==程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作（FULL  GC）==。



### 标记-复制算法

#### 定义

它将可用==内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。==
每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一点。

#### 演变

新生代中的对象有98%熬不过第一轮收集。因此并不需要按照1∶1的比例来划分新生代的内存空间。

把新生代分为一块`较大的Eden空间`和两块`较小的Survivor空间`，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，==然后直接清理掉Eden和已用过的那块Survivor空间==。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即`每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%）`，只有一个Survivor空间，即10%的新生代是会被“浪费”的。当然，98%的对象可被回收仅仅是“普通场景”下测得的数据，任何人都没有办法百分百保证每次回收都只有不多于10%的对象存活，因此Appel式回收还有一个充当罕见情况的“逃生门”的安全设计，`当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）。`

![image-20200918130742787](https://blog-1257815336.cos.ap-nanjing.myqcloud.com/typora/image-20200918130742787.png)

#### 分配担保

当出现大量对象在Minor GC后仍然存活的情况——最极端的情况就是内存回收后新生代中所有对象都存活，需要老年代进行分配担保，把Survivor无法容纳的对象直接送入老年代，这与生活中贷款担保类似。

老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，但一共有多少对象会在这次回收中活下来在实际完成内存回收之前是无法明确知道的，所以只能==`取之前每一次回收晋升到老年代对象容量的平均大小作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间`==。

取历史平均值来比较其实仍然是一种赌概率的解决办法，也就是说假如`某次MinorGC存活后的对象突增，远远高于历史平均值的话，依然会导致担保失败。如果出现了担保失败，那就只好老老实实地重新发起一次Full GC`



#### 缺点

==标记-复制算法在对象存活率较高时就要`进行较多的复制操作，效率将会降低`==。更关键的是，如果不想浪费50%的空间，就需要`有额外的空间进行分配担保`，以应对被使用的内存中所有对象都100%存活的极端情况，所以在`老年代一般不能直接选用这种算法。`



### 标记-整理算法

针对老年代对象的存亡特征，1974年Edward Lueders提出了另外一种有针对性的“标记-整理”（Mark-Compact）算法

#### 定义

标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是==让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存==。

![image-20200918131747431](https://blog-1257815336.cos.ap-nanjing.myqcloud.com/typora/image-20200918131747431.png)

标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策：

如果==移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种`对象移动操作`必须`全程暂停用户应用程序才能进行`，像这样的停顿被最初的虚拟机设计者形象地描述为“`Stop The World`”==

#### 和标记-清除的对比

==`移动则内存回收时会更复杂，不移动则内存分配时会更复杂。`==

如果跟标记-清除算法那样完全不考虑移动和整理存活对象的话，弥散于堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决。譬如通过“分区空闲分配链表”来解决内存分配问题。

内存的访问是用户程序最频繁的操作，甚至都没有之一，假如在这个环节上增加了额外的负担，势必会直接影响应用`程序的吞吐量`。

所`以标记-整理算法是以吞吐量为重要指标的一个算法。`

> HotSpot虚拟机里面关注吞吐量的Parallel Scavenge收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的，这也从侧面印证这点。

还有一种“和稀泥式”解决方案可以不在内存分配和访问上增加太大额外负担，做法是让虚拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。前面提到的基于标记-清除算法的CMS收集器面临空间碎片过多时采用的就是这种处理办法。



## 实现细节

### 1. 根节点枚举

迄今为止，所有收集器在==根节点枚举==这一步骤时都是必须暂停用户线程的，因此毫无疑问根节点枚举与之前提及的整理内存碎片一样会面临相似的“Stop The World”的困扰。

根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行——这里“一致性”的意思是整个枚举期间执行子系统看起来就像`被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化的情况，若这点不能满足的话，分析结果准确性也就无法保证。`

### 2. 安全点

**安全点，即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停**。Safepoint的选定既不能太少以至于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。

安全点的初始目的并不是让其他线程停下，而是找到一个稳定的执行状态。在这个执行状态下，Java虚拟机的堆栈不会发生变化。这么一来，垃圾回收器便能够“安全”地执行可达性分析。只要不离开这个安全点，Java虚拟机便能够在垃圾回收的同时，继续运行这段本地代码



### 3. 安全区域

安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点。

### 4. 记忆集与卡表

为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立了名为记忆集（Remembered Set）的数据结构，用以避免把整个老年代加进GC Roots扫描范围。

·卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。

“卡精度”所指的是用一种称为“卡表”（Card Table）的方式去实现记忆集，卡表最简单的形式可以只是一个字节数组。字节数组的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作“卡页”（Card Page）。

[详情见](https://zhuanlan.zhihu.com/p/87770882)