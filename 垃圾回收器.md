# 垃圾回收器

[toc]

![image-20200918141719100](https://blog-1257815336.cos.ap-nanjing.myqcloud.com/typora/JVM垃圾回收器.png)

如果两个收集器之间存在连线，就说明它们可以搭配使用，图中收集器所处的区域，则表示它是属于新生代收集器抑或是老年代收集器。

`JDK8 默认使用 UseParallelGC 即 Parallel Scavenge + Parallel Old`

## 新生代-Serial收集器

### 特点

1. 单线程
2. 进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束——==STOP THE WORLD==

![image-20200918143129804](https://blog-1257815336.cos.ap-nanjing.myqcloud.com/typora/image-20200918143129804.png)

### 使用算法

新生代：标记-复制

### 优点

1. 简单高效
2. 内存消耗最小：因为STP机制的存在，不需要存储额外的信息

### 使用场景

1.内存资源受限环境

2.单核机器

## 新生代-ParNew收集器

### 定义
新生代收集器
ParNew收集器实质上是Serial收集器的==多线程并行版本==

![image-20200918143532320](https://blog-1257815336.cos.ap-nanjing.myqcloud.com/typora/image-20200918143532320.png)

### 使用算法

新生代：标记-复制

### 特点

1. 使用多条线程进行垃圾收集
2. `除了Serial收集器外，目前只有它能与CMS收集器配合工作`


## 新生代-Parallel Scavenge收集器

### 特点

1. 目标是达到一个==可控制的吞吐量（Throughput）==。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值——吞吐量=运行用户代码的时间/（运行用户代码的时间+运行垃圾收集的时间）

2. **停顿时间越短就越适合需要与用户交互的程序**，良好的响应速度能提升用户体验。而**高吞吐量**则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合**在后台运算而不需要太多交互的任务**。

### 使用算法

新生代：标记-复制

## 老年代-Serial Old收集器

Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器

### 特点

1.单线程

### 使用算法

老年代：标记-整理

### 使用场景

一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用，另外一种就是作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用

## 老年代-Parallel Old收集器

Parallel Old是Parallel Scavenge收集器的老年代版本，支持==多线程并发收集==，基于==标记-整理==算法实现。

### 特点

1.支持多线程并发收集

### 使用算法

标记-整理算法

### 使用场景

在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑ParallelScavenge加Parallel Old收集器这个组合



## 老年代-CMS收集器

### 定义

CMS（Concurrent Mark Sweep）收集器是一种以==`获取最短回收停顿时间为目标的收集器`==。目前很大一部分的Java应用集中在互联网网站或者基于浏览器的B/S系统的服务端上，这类应用通常都会较为==关注`服务的响应速度`==，希望系统停顿时间尽可能短，以==给用户带来`良好的交互体验`==。CMS收集器就非常符合这类应用的需求。

### 收集过程
==非常重要==
1）初始标记（CMS initial mark）：==“Stop The World”==。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；

2）并发标记（CMS concurrent mark）：并发标记阶段就是从GCRoots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是==不需要停顿用户线程==，可以与垃圾收集线程一起并发运行；

3）重新标记（CMS remark）：==“Stop The World”==，修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；

4）并发清除（CMS concurrent sweep）：最后是并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。==“Stop The World”==

![image-20200921113355410](https://blog-1257815336.cos.ap-nanjing.myqcloud.com/typora/image-20200921113355410.png)

### 清除算法：

老年代：标记-清除



### 缺点

1. 并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量。
2. CMS收集器无法处理“==浮动垃圾==”（Floating Garbage），要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure）进而导致另一次完全“Stop The World”的FullGC的产生。在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。
3. 由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不得不启动后备预案：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集，但这样停顿时间就很长了。
4. CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给==大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC的情况==。



## 全年代-G1收集器

### 定义

面向局部收集的设计思路和基于Region的内存布局形式。“停顿时间模型”（Pause Prediction Model）的收集器，停顿时间模型的意思是能够支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标，

### 特点

==面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块`内存中存放的垃圾数量最多，回收收益最大`==，这就是G1收集器的MixedGC模式。

G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。
### 原理

G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，体的处理思路是让==G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默认值是200毫秒），优先处理回收价值收益最大的那些Region==，这也就是“Garbage First”名字的由来。

### 收集步骤

1. 初始标记：仅仅只是标记一下GC Roots能直接关联到的对象 ,==“Stop The World”==
2. 并发标记：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。 
3. 最终标记 Final Marking：`STP`==“Stop The World”==， 对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。
4. 筛选回收 Live Data Counting and Evacuation：==“Stop The World”==`STP`,负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后`把决定回收的那一部分Region的存活对象复制到空的Region中`，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。



![image-20200921132239846](https://blog-1257815336.cos.ap-nanjing.myqcloud.com/typora/image-20200921132239846.png)

### G1和CMS的对比

| 对比           | CMS                                          | G1                                               |
| -------------- | -------------------------------------------- | ------------------------------------------------ |
| 适用的内存区域 | 老年代                                       | 老年代+新生代                                    |
| 算法           | 标记-清除                                    | 整体来看是标记-整理，局部来看是标记-复制         |
| 阶段           | 初始标记 STW,并发标记，重新标记 STW,并发清理 | 初始标记 STW,并发标记，最终标记 STW,筛选回收 STW |
| 标记           | 并发                                         | 并行                                             |
| 停顿           | 不可预测                                     | 可预测                                           |
| 垃圾碎片       | 标记-清除产生空闲碎片                        | 不会产生                                         |
| 特点           | 并发收集，低停顿                             | 可控的垃圾回收时间                               |