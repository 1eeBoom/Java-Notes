# MySQL 索引优化

[toc]

## 1.最左前缀匹配原则

> 最左前缀匹配原则
>
> 在 MySQL 建立联合索引时，会遵守最左前缀匹配原则，即最左优先，在检索数据时候会从联合索引的最左边开始匹配。



索引的底层是一个 B+树，因此联合索引的底层也是一颗 B+树，只不过联合索引的 B+树节点中存储的是键值，由于构建一个 B+树，只能根据一个值来确定索引关系，所以数据库依赖联合索引中最左的字段来构建。

假设联合索引有 A,B,C 那么联合索引排序的时候是按照 A 进行排序，在 A 相等的情况下按 B 排，依次类推。

这是因为MySQL创建联合索引的规则是首先会对联合索引的最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序。**所以b=2这种查询条件没有办法利用索引**。

### 使用联合索引的情况

假设有一个联合索引（a,b,c），实际上相当于建立了三个索引（a）（a,b）（a,b,c）。

#### 1.全值匹配查询（所有查询都是使用的等号）

where后面的查询条件，不论是使用（a，b，c）（b，a，c）还是（c，b，a）顺序，在查询时都使用到了联合索引，可能有同学会疑惑，为什么底下两个的搜索条件明明没有按照联合索引从左到右进行匹配，却也使用到了联合索引？ 这是因为MySQL中有查询优化器explain，所以sql语句中字段的顺序不需要和联合索引定义的字段顺序相同，查询优化器会判断纠正这条SQL语句以什么样的顺序执行效率高，最后才能生成真正的执行计划，所以不论以何种顺序都可使用到联合索引。

#### 2.匹配最左边的列时

如果是依次按顺序匹配，则都可以匹配上。

![img](https://blog-1257815336.cos.ap-nanjing.myqcloud.com/%20typora/%20v2-f14be0159fbe6f551c4e35a927ec45f0_b.png)

但如果不是，比如 where c= and b = 这种不会使用到，一般只要是某联合索引的一部分，但又不遵循最左匹配原则时，都可能会采用index类型的方式扫描，但它的效率远不如最左匹配原则的查询效率高，index类型类型的扫描方式是从索引第一个字段一个一个的查找，直到找到符合的某个索引，与all不同的是，index是对所有索引树进行扫描，而all是对整个磁盘的数据进行全表扫描。

#### 3.模糊匹配列

　如果a是字符型，那么前缀匹配用的是索引，中坠和后缀用的是全表扫描。

select * from staffs where a like 'A%';//前缀都是排好序的，使用的都是联合索引

select * from staffs where a like '%A%';//全表查询

select * from staffs where a like '%A';//全表查询



#### 4.范围匹配

![img](https://blog-1257815336.cos.ap-nanjing.myqcloud.com/%20typora/%20v2-e77b87df07e16b29fc9ac063599458fc_b.png)

　在匹配的过程中遇到(>、<、between、like)号，就会`停止匹配（但当前的列仍然会匹配上）且必须严格按照顺序`，=和in可以乱序。



## 2.慢查询优化

### a.定位慢查询

通过开启 MySQL 的慢查询日志来进行定位

```sql
SET GLOBAL slow_query_log = 'ON'; #开启慢查询日志
SET GLOBAL slow_query_log_file = '文件路径（绝对路径）'; #设置文件路径
SET GLOBAL long_query_time = 1;  # 这里需要注意下，long_query_time参数设置后需要下次会话后才生效，当前会话查询还是原来的数值
```

### b.分析 SQL 语句

通过 explain 来对慢查询语句进行分析

#### explain 如何分析慢查询语句

在执行的时候 explain 加上慢查询 SQL 即可，会返回一系列指标。

在这些指标中最核心的指标是 rows，即扫描的行数。绝大多数 rows小的语句执行起来都很快。所以优化的最终目标都是降低 rows。

#### 核心指标

##### rows：根据表的统计信息和索引的使用情况，大致估算查询结果所需要读取记录的行数

##### type:针对单表的访问方法

1.system:查询对象表只有一行数据
2.constant:基于主键或者唯一索引查询，最多返回一条结果
3.eq_ref:基于主键或者唯一索引
4.ref:基于普通索引
5.range:利用索引范围查询
6.index:全索引扫描

7.all:全表扫描

查询效率由上到下递减。

##### key:实际上使用的索引

如果为NULL，则没有使用索引；若查询中使用了覆盖索引，则该索引只会出现在key列表中

##### extra 十分重要的额外信息

1.Using index ：表示覆盖索引即可满足查询要求，因而无需再回表查询
2.Distinct 优化Distinct操作，在找到匹配的第一行记录后，立马停止查找同样的值
3.using tmporary 使用临时表保存中间结果，常见于排序order by和分组group by

##### select_type: 查询的类型

1.SIMPLE 简单查询
2.PRIMARY 包含子查询，但当前为最外层的查询不符恩
3.UNION 联合查询的第二个及后面的查询
4.SUBQUERY 子查询



## 3.建立索引的几大原则

1.如果有几个查询条件是经常结合一起使用的，可以建立联合索引，建立的时候需要注意最左前缀匹配原则。

2.尽量选择区分度高的列作为索引，所谓的区分度是指 count(distinct col)/count(*)，即字段的值得不重复的比例，越接近于 1，索引的效果越好。

3.索引的列不能参与到计算当中，对索引列使用函数会使得索引失效。

4.尽量扩展索引而不是新建索引，索引会消耗额外的存储空间，同时在更新数据的时候也需要对索引进行更新。



## 4.不走索引的原因

1.查询条件没有索引列

2.建立的组合索引，但是查询条件不符合最左前缀匹配原则

3.查询条件中对索引列使用了函数或者计算

4.查询的数量超过整张表的一定比例，MySQL 自己优化成了全表扫描

5.百分号在前的模糊查询



## 5.大表查询优化

### 建索引

对常用且重复率低的字段，建索引。

### 增加过滤条件

查找有无查询条件,能使数据在进行使“索引失效、全表查询的语句"前大幅减小范围，例如，省、市，月份等

### 使用缓存

使用例如 ehcache、redis等工具进行缓存

### 拆表

## 6.分页查询优化

#### 分页查询过程

  1.首先通过非主键索引查询出所有条件的主键
  2.通过主键索引，定位到数据
  3.不断重复上述操作
  4.根据分页条件，确定返回数据的启始位置以及数据量
  5.返回数据
  **可以看出，初始位置值越大，定位时需要查询的数据就越多，查询效率也会越低**

limit是在查询结果基础上跳过多少条记录，也就是说，跳过多少条记录也是需要查询这些记录的信息的。如limit 10000,20，那么就需要10020次根据主键id到聚簇索引上面取记录信息，而select id就能减少这10020次查询，因为非聚簇索引上面存的就是主键id。前提是where后面的条件必须确保都是走索引，在全表扫描下，任何优化都是徒劳。


将原来的`sql`拆分为两部分。第一部分是去掉`select`选项，只保留`ID`，然后去掉多表连接。第一部分主要就是保留`where`后面的条件查询。根据条件查询，获取当前分页的记录的主键`id`。在这一部完成分页。

先根据筛选条件完成分页查询获取当前页的`id`

第二部分再是根据获取到的当前页的记录`id`去查询需要的字段。



使用先使用范围查询定位 id （或者索引），然后再使用索引进行定位数据，能够提高好几倍查询速度。即先 select id，然后再 select *；

先把符合条件的主键找到，然后通过主键去定位符合条件的数据，这里优化了2个点：**1.通过索引覆盖避免了回表;2.通过主键直接定位数据的方法，省去了在数据集中查询初始位置的过程**

https://www.cnblogs.com/nedulee/p/12542104.html